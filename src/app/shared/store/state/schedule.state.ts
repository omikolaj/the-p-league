import { Action, createSelector, Selector, State, StateContext } from '@ngxs/store';
import { produce } from 'immer';
import { Observable } from 'rxjs';
import { catchError, switchMap, tap } from 'rxjs/operators';
import { ActiveSessionInfo } from 'src/app/core/models/schedule/active-session-info.model';
import LeagueSessionSchedule from 'src/app/core/models/schedule/classes/league-session-schedule.model';
import Match from 'src/app/core/models/schedule/classes/match.model';
import { ScheduleAsyncService } from 'src/app/core/services/schedule/schedule-async.service';
import * as Schedule from '../actions/schedules.actions';

export interface ScheduleStateModel {
	// entties is used by the admin preview component to display the
	// matches user has created so far before publishing
	entities: {
		[id: string]: LeagueSessionSchedule;
	};
	activeSessionsInfo: {
		[id: string]: ActiveSessionInfo;
	};
	// activeEntities refers to the active league sessions
	// that get fetched from the server
	activeEntities: {
		[id: string]: LeagueSessionSchedule;
	};
	// IDs collection refers to the activeEntities collection and NOT the entities one
	IDs: string[];
}

@State<ScheduleStateModel>({
	name: 'schedules',
	defaults: {
		entities: {},
		activeSessionsInfo: {},
		activeEntities: {},
		// IDs collection referes to the activeEntities collection of entities
		IDs: []
	}
})
export class ScheduleState {
	constructor(private scheduleAsync: ScheduleAsyncService) {}

	/**
	 * @description Selects the sessions that were generated by the admin client side
	 * @returns sessions generated by the admin
	 */
	@Selector()
	static getSessions(state: ScheduleStateModel): LeagueSessionSchedule[] {
		return Object.values(state.entities);
	}

	@Selector()
	static getMatches(state: ScheduleStateModel): Match[] {
		let matches: Match[] = [];
		Object.values(state.entities).forEach((entity) => {
			matches = [...matches, ...entity.matches];
		});
		return matches;
	}

	@Selector()
	static getActiveSessionsMatches(state: ScheduleStateModel): Match[] {
		let matches: Match[] = [];
		if (state) {
			Object.values(state.activeEntities).forEach((entity) => {
				matches = [...matches, ...entity.matches];
			});
		}
		return matches;
	}

	@Selector()
	static getSessionsLeagueIDs(state: ScheduleStateModel): string[] {
		return Object.values(state.entities).map((entity) => entity.leagueID);
	}

	@Selector()
	static getSessionInfoByLeagueID(state: ScheduleStateModel): (id: string) => ActiveSessionInfo {
		return (id: string): ActiveSessionInfo => Object.values(state.activeSessionsInfo).find((activeSession) => activeSession.leagueId === id);
	}

	static getActiveSessionInfoForLeagueID(id: string) {
		return createSelector(
			[ScheduleState],
			(state: ScheduleStateModel): ActiveSessionInfo => {
				return Object.values(state.activeSessionsInfo).find((activeSession) => activeSession.leagueId === id);
			}
		);
	}

	/**
	 * @description Returns the active sessions that were fetched from the server
	 * @returns active sessions fetched from server
	 */
	@Selector()
	static getActiveSessions(state: ScheduleStateModel): LeagueSessionSchedule[] {
		return Object.values(state.activeEntities);
	}

	@Action(Schedule.FetchLeaguesSessionSchedules)
	fetchSessions(ctx: StateContext<ScheduleStateModel>): Observable<void> {
		return this.scheduleAsync.fetchLeaguesSessionSchedules().pipe(
			tap((sessions) => ctx.dispatch(new Schedule.InitializeLeagueSessionSchedules(sessions))),
			switchMap(() => ctx.dispatch(new Schedule.FetchLeaguesSessionSchedulesSuccess())),
			catchError((err) => ctx.dispatch(new Schedule.FetchLeaguesSesssionSchedulesFailed(err)))
		);
	}

	@Action(Schedule.InitializeLeagueSessionSchedules)
	initializeLeagueSessionSchedules(ctx: StateContext<ScheduleStateModel>, action: Schedule.InitializeLeagueSessionSchedules): void {
		console.log('sessions', action.payload);
		ctx.setState(
			produce((draft: ScheduleStateModel) => {
				action.payload.forEach((session) => {
					// in case there are no sessions
					if (session) {
						draft.activeEntities[session.id] = session;
						draft.IDs.push(session.id);
					}
				});
			})
		);
	}

	@Action(Schedule.FetchLeaguesSessionSchedulesSuccess)
	fetchSessionsSuccess(ctx: StateContext<ScheduleStateModel>) {}

	@Action(Schedule.FetchLeaguesSesssionSchedulesFailed)
	fetchSessionsFailed(ctx: StateContext<ScheduleStateModel>) {}

	@Action(Schedule.InitializeActiveSessionsInfo)
	initializeActiveSessionsInfo(ctx: StateContext<ScheduleStateModel>, action: Schedule.InitializeActiveSessionsInfo): void {
		ctx.setState(
			produce((draft: ScheduleStateModel) => {
				action.activeSessions.forEach((activeSession) => {
					if (activeSession) {
						draft.activeSessionsInfo[activeSession.sessionId] = activeSession;
					}
				});
			})
		);
	}

	/**
	 * @description Creates sessions for the selected leagues. This can only create a new
	 * session per selected league. This is only used to store the created sessions so the
	 * Preview component can display them. Entities state of this store slice should be cleared
	 * once user publishes schedules
	 * @param ctx
	 * @param action
	 */
	@Action(Schedule.CreateSchedules)
	createSessions(ctx: StateContext<ScheduleStateModel>, action: Schedule.CreateSchedules): void {
		ctx.setState(
			produce((draft: ScheduleStateModel) => {
				action.newSessions.forEach((session) => {
					session.teams.forEach((t) => {
						session.teamsSessions = (session.teamsSessions || []).concat({
							teamId: t.id
						});
					});
					// clear teams array because we do not want to be sending teams to the server just the ids
					// session.teams collection is used by one of the generateSchedules methods to create matches
					// this gets fired prior to this method (this method meaning createSessions)
					session.teams = [];
					// this has to be session.leagueID because at the time of adding sessions to the store
					// in order to display them in the preview, we do not have session.id.
					draft.entities[session.leagueID] = session;
				});
			})
		);
	}

	@Action(Schedule.ClearSchedules)
	clearSessions(ctx: StateContext<ScheduleStateModel>): void {
		ctx.setState(
			produce((draft: ScheduleStateModel) => {
				draft.entities = {};
			})
		);
	}

	@Action(Schedule.UpdateMatchResult)
	updateMatchResult(ctx: StateContext<ScheduleStateModel>, action: Schedule.UpdateMatchResult): void {
		// console.warn('Update match results client side is NOT implemented. Payload is: ', action.matchResult);
		ctx.setState(
			produce((draft: ScheduleStateModel) => {
				const session: LeagueSessionSchedule = draft.activeEntities[action.matchResult.sessionId];
				if (session) {
					const match: Match = session.matches.find((m) => m.id === action.matchResult.matchId);
					if (match) {
						match.matchResult = action.matchResult;
					}
				}
			})
		);
	}
}
